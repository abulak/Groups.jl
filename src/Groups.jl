module Groups

using AbstractAlgebra
import AbstractAlgebra: Group, GroupElem, Ring
import AbstractAlgebra: parent, parent_type, elem_type
import AbstractAlgebra: order, gens, matrix_repr

import Base: length, ==, hash, show, convert, eltype, iterate
import Base: inv, reduce, *, ^, power_by_squaring
import Base: findfirst, findnext, replace
import Base: deepcopy_internal

using LinearAlgebra
using Markdown


include("types.jl")

include("FreeGroup.jl")
include("FPGroups.jl")
include("AutGroup.jl")

include("symbols.jl")
include("fallbacks.jl")
include("words.jl")
include("hashing.jl")
include("freereduce.jl")
include("arithmetic.jl")
include("findreplace.jl")

include("DirectPower.jl")
include("WreathProducts.jl")


###############################################################################
#
#   String I/O
#

@doc doc"""
    show(io::IO, W::GWord)
> The actual string produced by show depends on the eltype of `W.symbols`.

"""
function Base.show(io::IO, W::GWord)
    if length(W) == 0
        print(io, "(id)")
    else
        join(io, (string(s) for s in syllables(W)), "*")
    end
end

function Base.show(io::IO, s::T) where {T<:GSymbol}
    if s.pow == 1
       print(io, string(s.id))
    else
       print(io, "$(s.id)^$(s.pow)")
    end
end

###############################################################################
#
#   Misc
#

@doc doc"""
    gens(G::AbstractFPGroups)
> returns vector of generators of `G`, as its elements.
"""
AbstractAlgebra.gens(G::AbstractFPGroup) = G.(G.gens)

@doc doc"""
    metric_ball(S::Vector{GroupElem}, center=Id; radius=2, op=*)
Compute metric ball as a list of elements of non-decreasing length, given the
word-length metric on group generated by `S`. The ball is centered at `center`
(by default: the identity element). `radius` and `op` keywords specify the
radius and multiplication operation to be used.
"""
function generate_balls(S::AbstractVector{T}, center::T=one(first(S));
        radius=2, op=*) where T<:Union{GroupElem, NCRingElem}
    sizes = Int[]
    B = [one(first(S))]
    for i in 1:radius
        BB = [op(i,j) for (i,j) in Base.product(B,S)]
        B = unique([B; vec(BB)])
        push!(sizes, length(B))
    end
    isone(center) && return B, sizes
    return c.*B, sizes
end

end # of module Groups
